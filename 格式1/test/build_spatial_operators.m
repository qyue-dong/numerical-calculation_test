function ops = build_spatial_operators(N, h)
%% 0. 基础
I_N = speye(N);
e   = ones(N,1);

%% 1. 一维 4 阶一阶导 C1   (对应 δ_x, δ_y)  -------------------------
% 经典 4 阶中心格式：
%   f'(x_i) ≈ (-1/12 f_{i-2} + 2/3 f_{i-1} - 2/3 f_{i+1} + 1/12 f_{i+2}) / h
%
% 内点用统一 stencil，边界用专门修正系数，使整体保持四阶。
d0 = zeros(N,1);
d1 = (2/3)*ones(N,1);
d2 = (-1/12)*ones(N,1);

C1 = spdiags([-d2, -d1, d0, d1, d2], -2:2, N, N);

% 左边界 1,2 点的 4 阶边界格式（文档中与常见 4 阶边界修正一致）
C1(1,1:5) = [-25/12, 4, -3, 4/3, -1/4];
C1(2,1:5) = [-1/4, -5/6, 3/2, -1/2, 1/12];

% 右边界用反对称性（导数算子反对称）
C1(N,N-4:N)   = -fliplr(C1(1,1:5));
C1(N-1,N-4:N) = -fliplr(C1(2,1:5));

C1 = C1 / h;

%% 2. 一维 4 阶二阶导 C2_D   (Dirichlet 用) ------------------------
% 经典 4 阶中心二阶导：
%   f''(x_i) ≈ (-1/12 f_{i-2} + 4/3 f_{i-1} - 5/2 f_i + 4/3 f_{i+1} -1/12 f_{i+2}) / h^2
%
d0 = (-5/2)*ones(N,1);
d1 = (4/3)*ones(N,1);
d2 = (-1/12)*ones(N,1);

C2_D = spdiags([d2, d1, d0, d1, d2], -2:2, N, N);

% 四阶边界修正（与你原来代码保持一致，符合文档导出的精度）
C2_D(1, 1:6) = [45, -154, 214, -156, 61, -10] / 12;
C2_D(2, 1:6) = [10, -15, -4, 14, -6, 1] / 12;

C2_D(N,  N-5:N)   = fliplr(C2_D(1,1:6));
C2_D(N-1,N-5:N)   = fliplr(C2_D(2,1:6));

C2_D = C2_D / h^2;

%% 3. 一维 2 阶二阶导 C2_N   (Neumann / 压力 Poisson 用) ----------
e2   = ones(N,1);
C2_N = spdiags([e2, -2*e2, e2], -1:1, N, N);

% Neumann 边界：一阶导为 0 => 用 [-1,1]/h 实现
C2_N(1,1:2)     = [-1, 1];
C2_N(N,N-1:N)   = [ 1,-1];

C2_N = C2_N / h^2;

%% 4. 一维 B-算子的 1D 模板矩阵 C3, C4, C5  ----------------------
% 文档第 8–9 页给出:
%   C3: 对角 10，邻对角 1  (对应 B2, B3)   系数整体 1/12
%   C4: 对角 14，邻对角 -1  (对应 B4)       系数整体 1/12
%   C5: 对角  8，邻对角 -1  (对应 B5)       系数整体 1/6
%
C3 = spdiags([e, 10*e, e], -1:1, N, N);   % 10-1-1
C4 = spdiags([-e, 14*e, -e], -1:1, N, N);   % 14-1-1
C5 = spdiags([-e,  8*e, -e], -1:1, N, N);   % 8-1-1

%% 5. 通过 Kronecker 构造 2D A_i 算子 -----------------------------
% A1, A2: 一阶导 (4 阶)
ops.A1 = kron(C1,  I_N);     % d/dx
ops.A2 = kron(I_N, C1);      % d/dy

% A3, A5: 二阶导 (4 阶)
ops.A3 = kron(C2_D, I_N);    % d^2/dx^2
ops.A5 = kron(I_N, C2_D);    % d^2/dy^2

% A4: 文档给出 H1 = B1 + A4 且 A4 = (h^2/12)(A3 + A5)
%     —— 注意：不是 (h^2/12)*A3 ！！
ops.A4 = (h^2/12) * (ops.A3 + ops.A5);

%% 6. 2D B_i 算子 -----------------------------------------------
% B2, B3 使用 C3，整体系数 1/12
ops.B2 = kron(C3, I_N) / 12;   % x 方向 “紧致修正”
ops.B3 = kron(I_N, C3) / 12;   % y 方向 “紧致修正”

% B4 使用 C4，整体系数 1/12
ops.B4 = kron(C4, I_N) / 12;

% B5 使用 C5，整体系数 1/6
ops.B5 = kron(I_N, C5) / 6;

%% 7. 组合 H1, H2 (文档式 (16),(17)) ------------------------------
% B1 = B2 + B3   （注意：文档中没有 “-I”，之前的 B2+B3-I 是错误的）
B1_op = ops.B2 + ops.B3;

% H1 = B1 + A4
ops.H1 = B1_op + ops.A4;

% H2 = B2*A3 + B3*A5
ops.H2 = ops.B2 * ops.A3 + ops.B3 * ops.A5;

%% 8. 压力梯度与 Laplacian ---------------------------------------
% 压力梯度：Grad_x = B4*A1, Grad_y = B5*A2
% 这里的 B4, B5 与文档中 (21),(22) 中的 B4,B5 作用是完全一致的。
ops.Grad_x = ops.B4 * ops.A1;
ops.Grad_y = ops.B5 * ops.A2;

% 压力 Poisson 的 Neumann Laplacian（2 阶，常规）
ops.Lp_N = kron(C2_N, I_N) + kron(I_N, C2_N);

end
